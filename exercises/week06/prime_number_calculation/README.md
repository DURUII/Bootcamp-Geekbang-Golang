- 任务和任务之间不存在依赖关系，所以可以采用任务并发方式处理。这是在并发场景的分而治之。
- 参考 MapReduce 思想，我们应该先考虑将任务拆分，再考虑排序。例如，
    - 将任务拆分成 4 个，每个任务负责计算 1/4 的范围。
    - 每个任务负责计算 1/4 的范围，例如：
        - 任务 1 负责计算 1 ~ 1000000000/4
        - 任务 2 负责计算 1000000000/4 ~ 1000000000/2
        - 任务 3 负责计算 1000000000/2 ~ 3000000000/4
        - 任务 4 负责计算 3000000000/4 ~ 3000000000
    - 计算完后，再将结果排序。
- 当然，虽然题目设置了协程数固定为 4 个，但是这并不代表，我们要把任务也固定为 4 个；可以根据 benchmark 实验结果，确定要将
  start ~ end 之间拆分成几个范围。甚至我们可以考虑，每个数字是一个任务（生产者），负责完成任务的 4 个协程是消费者。
- 什么时候每个数字都已经判断过一次了？或者说什么时候结束？那么我们需要一个计数器（考虑用 waitGroup），或者需要一个 完成消息的通道（close 后，获得一个零值）。
- 假如要考虑容错，那么需要给予 lease，若若干秒后仍未返回，交由另一个协程完成；但是这个任务并不设置大规模分布式集群，而是一个单体应用更不需要 RPC 进行通讯，因此我们可以认为每个协程都能正确执行任务，不考虑容错。
